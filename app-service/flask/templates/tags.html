<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jamming bot — Tag Cloud</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      color: #fff;
      font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
      font-family: monospace;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 20px;
      font-size: 11px;
      color: #666;
      z-index: 10;
      display: flex;
      justify-content: space-between;
    }
    nav a { color: #555; text-decoration: none; margin-right: 12px; }
    nav a:hover { color: #fff; }
    #status { color: #333; font-size: 10px; }

    canvas { display: block; cursor: default; }

    #console {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.85);
      border-top: 1px solid #222;
      overflow-y: auto;
      padding: 6px 10px;
      font-family: monospace;
      font-size: 10px;
      color: #555;
      z-index: 20;
      pointer-events: auto;
    }
    #console .line { white-space: pre; margin: 0; }
    #console .ts { color: #333; }
    #console .ws { color: #4a8; }
  </style>
</head>
<body>

<nav>
  <div>
    <a href="/">← home</a>
    <a href="/tags/phrases/">phrases</a>
  </div>
  <span id="status"></span>
</nav>

<canvas id="cloud"></canvas>
<div id="console"></div>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
<script>
(function () {
  var API = '/api/tags/get/';
  var REFRESH_INTERVAL = 30000;
  var REPEL_RADIUS = 150;
  var REPEL_STRENGTH = 80;
  var RETURN_SPEED = 0.06;
  var FONT = 'monospace';
  var PAD = 6;

  var statusEl = document.getElementById('status');
  var canvas = document.getElementById('cloud');
  var ctx = canvas.getContext('2d');
  var consoleEl = document.getElementById('console');
  var MAX_LINES = 200;

  function wsLog(msg) {
    var now = new Date();
    var ts = [now.getHours(), now.getMinutes(), now.getSeconds()]
      .map(function (n) { return n < 10 ? '0' + n : n; }).join(':');
    var line = document.createElement('p');
    line.className = 'line';
    line.innerHTML = '<span class="ts">' + ts + '</span> <span class="ws">' + msg + '</span>';
    consoleEl.appendChild(line);
    while (consoleEl.children.length > MAX_LINES) {
      consoleEl.removeChild(consoleEl.firstChild);
    }
    consoleEl.scrollTop = consoleEl.scrollHeight;
    console.log('[ws] ' + msg);
  }

  var W, H;
  var mouse = { x: -9999, y: -9999 };
  var particleMap = {};
  var particles = [];
  var raf;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  }
  resize();

  window.addEventListener('resize', function () {
    resize();
    particles.forEach(function (p) {
      p.homeX = Math.min(W - 40, Math.max(40, p.homeX));
      p.homeY = Math.min(H - 20, Math.max(44, p.homeY));
    });
  });

  canvas.addEventListener('mousemove', function (e) {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });
  canvas.addEventListener('mouseleave', function () {
    mouse.x = -9999;
    mouse.y = -9999;
  });

  canvas.addEventListener('touchstart', function (e) {
    e.preventDefault();
    var t = e.touches[0];
    mouse.x = t.clientX;
    mouse.y = t.clientY;
  }, { passive: false });
  canvas.addEventListener('touchmove', function (e) {
    e.preventDefault();
    var t = e.touches[0];
    mouse.x = t.clientX;
    mouse.y = t.clientY;
  }, { passive: false });
  canvas.addEventListener('touchend', function () {
    mouse.x = -9999;
    mouse.y = -9999;
  });
  canvas.addEventListener('touchcancel', function () {
    mouse.x = -9999;
    mouse.y = -9999;
  });

  function randomPos(tw, th) {
    var margin = 50;
    var x = margin + Math.random() * (W - tw - margin * 2) + tw / 2;
    var y = margin + Math.random() * (H - th - margin * 2) + th / 2;
    return { x: x, y: y };
  }

  function calcSize(count, maxCount) {
    var minSize = 11;
    var maxSize = Math.min(W, H) / 9;
    var ratio = Math.sqrt(count / maxCount);
    return minSize + ratio * (maxSize - minSize);
  }

  function calcColor(count, maxCount) {
    var ratio = Math.sqrt(count / maxCount);
    var bright = 35 + Math.round(ratio * 190);
    return 'rgb(' + bright + ',' + bright + ',' + bright + ')';
  }

  function measureWord(text, size) {
    ctx.font = size + 'px ' + FONT;
    return ctx.measureText(text).width;
  }

  // Scatter placement: random positions with overlap relaxation
  function scatterPlace(list) {
    // Measure all
    for (var i = 0; i < list.length; i++) {
      var p = list[i];
      p._w = measureWord(p.text, p.size);
      p._h = p.size;
    }

    // Sort biggest first for placement priority
    list.sort(function (a, b) { return b.size - a.size; });

    // Place each word randomly, with a few retries to avoid overlap
    var placed = [];
    for (var i = 0; i < list.length; i++) {
      var p = list[i];
      var best = null;
      var bestOverlap = Infinity;

      for (var attempt = 0; attempt < 30; attempt++) {
        var pos = randomPos(p._w, p._h);
        var overlapCount = 0;

        for (var j = 0; j < placed.length; j++) {
          var q = placed[j];
          if (rectsOverlap(pos.x, pos.y, p._w, p._h, q.homeX, q.homeY, q._w, q._h)) {
            overlapCount++;
          }
        }

        if (overlapCount === 0) {
          best = pos;
          break;
        }
        if (overlapCount < bestOverlap) {
          bestOverlap = overlapCount;
          best = pos;
        }
      }

      p.homeX = best.x;
      p.homeY = best.y;
      placed.push(p);
    }
  }

  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    var al = ax - aw / 2 - PAD, ar = ax + aw / 2 + PAD;
    var at = ay - ah / 2 - PAD, ab = ay + ah / 2 + PAD;
    var bl = bx - bw / 2 - PAD, br = bx + bw / 2 + PAD;
    var bt = by - bh / 2 - PAD, bb = by + bh / 2 + PAD;
    return al < br && ar > bl && at < bb && ab > bt;
  }

  function mergeParticles(tags) {
    var maxCount = 1;
    for (var i = 0; i < tags.length; i++) {
      if (tags[i].count > maxCount) maxCount = tags[i].count;
    }

    var newMap = {};
    var toPlace = [];

    for (var i = 0; i < tags.length; i++) {
      var t = tags[i];
      var key = t.name;
      var size = calcSize(t.count, maxCount);
      var color = calcColor(t.count, maxCount);

      if (particleMap[key]) {
        // Existing tag: update size/color, keep position
        var p = particleMap[key];
        p.targetSize = size;
        p.targetColor = color;
        p.count = t.count;
        p._w = measureWord(p.text, size);
        p._h = size;
        p.removing = false;
        p.opacity = typeof p.opacity === 'number' ? p.opacity : 1;
        newMap[key] = p;
      } else {
        // New tag: create particle, will need placement
        var p = {
          text: t.name,
          count: t.count,
          size: size * 0.01,
          targetSize: size,
          color: color,
          targetColor: color,
          homeX: 0, homeY: 0,
          x: 0, y: 0,
          vx: 0, vy: 0,
          opacity: 0,
          removing: false,
          _w: 0, _h: 0
        };
        p._w = measureWord(p.text, size);
        p._h = size;
        newMap[key] = p;
        toPlace.push(p);
      }
    }

    // Mark removed tags for fade-out
    for (var key in particleMap) {
      if (!newMap[key]) {
        var p = particleMap[key];
        p.removing = true;
        newMap[key] = p;
      }
    }

    // Place only new tags in random spots
    if (toPlace.length) {
      scatterPlace(toPlace);
      for (var i = 0; i < toPlace.length; i++) {
        var p = toPlace[i];
        p.x = p.homeX;
        p.y = p.homeY;
      }
    }

    particleMap = newMap;
    particles = [];
    for (var key in particleMap) {
      particles.push(particleMap[key]);
    }
  }

  function fetchAndDraw() {
    statusEl.textContent = 'updating…';
    fetch(API)
      .then(function (r) { return r.json(); })
      .then(function (tags) {
        if (!tags || !tags.length) {
          statusEl.textContent = 'no tags';
          return;
        }
        mergeParticles(tags);
        if (!raf) animate();
        statusEl.textContent = tags.length + ' tags';
      })
      .catch(function (err) {
        console.error(err);
        statusEl.textContent = 'error';
      });
  }

  function lerpColor(from, to, t) {
    var f = from.match(/\d+/g).map(Number);
    var tt = to.match(/\d+/g).map(Number);
    var r = Math.round(f[0] + (tt[0] - f[0]) * t);
    var g = Math.round(f[1] + (tt[1] - f[1]) * t);
    var b = Math.round(f[2] + (tt[2] - f[2]) * t);
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  }

  function animate() {
    ctx.clearRect(0, 0, W, H);

    var toRemove = [];

    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];

      // Animate size towards target
      if (p.targetSize) {
        p.size += (p.targetSize - p.size) * 0.08;
      }

      // Animate color
      if (p.targetColor && p.color !== p.targetColor) {
        p.color = lerpColor(p.color, p.targetColor, 0.08);
      }

      // Fade in new / fade out removed
      if (p.removing) {
        p.opacity -= 0.02;
        if (p.opacity <= 0) {
          toRemove.push(p.text);
          continue;
        }
      } else if (p.opacity < 1) {
        p.opacity = Math.min(1, p.opacity + 0.03);
      }

      // Mouse repel
      var dx = p.x - mouse.x;
      var dy = p.y - mouse.y;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < REPEL_RADIUS && dist > 0) {
        var force = (REPEL_RADIUS - dist) / REPEL_RADIUS * REPEL_STRENGTH;
        p.vx += (dx / dist) * force * 0.08;
        p.vy += (dy / dist) * force * 0.08;
      }

      // Spring back to home
      p.vx += (p.homeX - p.x) * RETURN_SPEED;
      p.vy += (p.homeY - p.y) * RETURN_SPEED;

      p.vx *= 0.82;
      p.vy *= 0.82;

      p.x += p.vx;
      p.y += p.vy;

      // Draw
      ctx.globalAlpha = p.opacity;
      ctx.font = Math.round(p.size) + 'px ' + FONT;
      ctx.fillStyle = p.color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.text, p.x, p.y);
    }

    ctx.globalAlpha = 1;

    // Cleanup fully faded particles
    for (var i = 0; i < toRemove.length; i++) {
      delete particleMap[toRemove[i]];
    }
    if (toRemove.length) {
      particles = [];
      for (var key in particleMap) particles.push(particleMap[key]);
    }

    raf = requestAnimationFrame(animate);
  }

  fetchAndDraw();
  setInterval(fetchAndDraw, REFRESH_INTERVAL);

  var socket = io({ transports: ['websocket', 'polling'] });
  socket.on('connect', function () {
    statusEl.textContent = 'live';
    wsLog('connected');
  });
  socket.on('tags_updated', function (data) {
    wsLog('tags_updated' + (data ? ' ' + JSON.stringify(data) : ''));
    fetchAndDraw();
  });
  socket.on('step', function (data) {
    wsLog('step ' + (data && data.url ? data.url : JSON.stringify(data)));
  });
  socket.on('screenshot', function (data) {
    wsLog('screenshot ' + (data && data.screenshot_url ? data.screenshot_url : JSON.stringify(data)));
  });
  socket.on('location', function (data) {
    wsLog('location ' + JSON.stringify(data));
  });
  socket.on('analyzed', function (data) {
    if (data.tags) {
      fetchAndDraw();
    }
    wsLog('analyzed ' + JSON.stringify(data));
  });
  socket.on('disconnect', function () {
    statusEl.textContent = 'disconnected';
    wsLog('disconnected');
  });
})();
</script>

</body>
</html>
