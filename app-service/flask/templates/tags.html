<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jamming bot — Tag Cloud</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      color: #fff;
      font-family: "Lucida Grande", Arial, Helvetica, sans-serif;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    nav {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 12px 20px;
      font-size: 11px;
      color: #666;
      z-index: 10;
      display: flex;
      justify-content: space-between;
    }
    nav a { color: #555; text-decoration: none; margin-right: 12px; }
    nav a:hover { color: #fff; }
    #status { color: #333; font-size: 10px; }

    canvas { display: block; cursor: default; }
  </style>
</head>
<body>

<nav>
  <div>
    <a href="/">← home</a>
    <a href="/tags/phrases/">phrases</a>
  </div>
  <span id="status"></span>
</nav>

<canvas id="cloud"></canvas>

<script>
(function () {
  var API = '/api/tags/get/';
  var REFRESH_INTERVAL = 30000;
  var REPEL_RADIUS = 150;
  var REPEL_STRENGTH = 80;
  var RETURN_SPEED = 0.06;
  var FONT = '"Lucida Grande", Arial, Helvetica, sans-serif';

  var statusEl = document.getElementById('status');
  var canvas = document.getElementById('cloud');
  var ctx = canvas.getContext('2d');

  var W, H, cx, cy;
  var mouse = { x: -9999, y: -9999 };
  var particles = [];
  var raf;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    cx = W / 2;
    cy = H / 2;
    canvas.width = W;
    canvas.height = H;
  }
  resize();

  window.addEventListener('resize', function () {
    resize();
    if (particles.length) layoutWords();
  });

  canvas.addEventListener('mousemove', function (e) {
    mouse.x = e.clientX;
    mouse.y = e.clientY;
  });
  canvas.addEventListener('mouseleave', function () {
    mouse.x = -9999;
    mouse.y = -9999;
  });

  function fetchAndDraw() {
    statusEl.textContent = 'updating…';
    fetch(API)
      .then(function (r) { return r.json(); })
      .then(function (tags) {
        if (!tags || !tags.length) {
          statusEl.textContent = 'no tags';
          return;
        }
        buildParticles(tags);
        statusEl.textContent = tags.length + ' tags';
      })
      .catch(function (err) {
        console.error(err);
        statusEl.textContent = 'error';
      });
  }

  function buildParticles(tags) {
    var maxCount = 1;
    for (var i = 0; i < tags.length; i++) {
      if (tags[i].count > maxCount) maxCount = tags[i].count;
    }

    var minSize = 11;
    var maxSize = Math.min(W, H) / 10;

    particles = tags.map(function (t) {
      var ratio = Math.sqrt(t.count / maxCount);
      var size = minSize + ratio * (maxSize - minSize);
      var bright = 40 + Math.round(ratio * 180);
      return {
        text: t.name,
        count: t.count,
        size: size,
        color: 'rgb(' + bright + ',' + bright + ',' + bright + ')',
        homeX: 0, homeY: 0,
        x: 0, y: 0,
        vx: 0, vy: 0
      };
    });

    layoutWords();
    if (!raf) animate();
  }

  function layoutWords() {
    // Simple spiral placement
    particles.sort(function (a, b) { return b.size - a.size; });
    var placed = [];

    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];
      ctx.font = p.size + 'px ' + FONT;
      var tw = ctx.measureText(p.text).width;
      var th = p.size;
      p._w = tw;
      p._h = th;

      var ok = false;
      for (var r = 0; r < Math.max(W, H); r += 3) {
        var step = Math.max(0.05, 0.5 / (r + 1));
        for (var a = 0; a < Math.PI * 2; a += step) {
          var tx = cx + r * Math.cos(a);
          var ty = cy + r * Math.sin(a);
          var left = tx - tw / 2;
          var top = ty - th / 2;
          var right = left + tw;
          var bottom = top + th;

          if (left < 4 || top < 36 || right > W - 4 || bottom > H - 4) continue;

          var overlap = false;
          for (var j = 0; j < placed.length; j++) {
            var q = placed[j];
            var ql = q.homeX - q._w / 2 - 4;
            var qt = q.homeY - q._h / 2 - 2;
            var qr = ql + q._w + 8;
            var qb = qt + q._h + 4;
            if (left < qr && right > ql && top < qb && bottom > qt) {
              overlap = true;
              break;
            }
          }
          if (!overlap) {
            p.homeX = tx;
            p.homeY = ty;
            p.x = tx;
            p.y = ty;
            placed.push(p);
            ok = true;
            break;
          }
        }
        if (ok) break;
      }
      if (!ok) {
        p.homeX = cx + (Math.random() - 0.5) * W * 0.8;
        p.homeY = cy + (Math.random() - 0.5) * H * 0.8;
        p.x = p.homeX;
        p.y = p.homeY;
      }
    }
  }

  function animate() {
    ctx.clearRect(0, 0, W, H);

    for (var i = 0; i < particles.length; i++) {
      var p = particles[i];

      var dx = p.x - mouse.x;
      var dy = p.y - mouse.y;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < REPEL_RADIUS && dist > 0) {
        var force = (REPEL_RADIUS - dist) / REPEL_RADIUS * REPEL_STRENGTH;
        p.vx += (dx / dist) * force * 0.08;
        p.vy += (dy / dist) * force * 0.08;
      }

      p.vx += (p.homeX - p.x) * RETURN_SPEED;
      p.vy += (p.homeY - p.y) * RETURN_SPEED;

      p.vx *= 0.82;
      p.vy *= 0.82;

      p.x += p.vx;
      p.y += p.vy;

      ctx.font = p.size + 'px ' + FONT;
      ctx.fillStyle = p.color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(p.text, p.x, p.y);
    }

    raf = requestAnimationFrame(animate);
  }

  fetchAndDraw();
  setInterval(fetchAndDraw, REFRESH_INTERVAL);
})();
</script>

</body>
</html>
