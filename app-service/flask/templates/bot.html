<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"/>
  <title>Jamming bot v2.1.0</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/flask_static/manifest.json">
  
  <!-- Favicon -->
  <link rel="icon" href="/flask_static/favicon.ico" type="image/x-icon">
  
  <!-- iOS Fullscreen App Meta Tags -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Jamming Bot">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">
  
  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" href="/flask_static/logo192.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/flask_static/logo192.png">
  <link rel="apple-touch-icon" sizes="512x512" href="/flask_static/logo512.png">
  
  <!-- Description -->
  <meta name="description" content="Jamming bot visualization and monitoring">
<style>
    body, table {
    margin: 0px;
    padding: 0px;
    font-family:"Conv_Gals-Light", "Lucida Grande","Lucida Sans Unicode", Arial, Verdana, sans-serif;
    font-size:32px;
    color:#ffffff;
}

html, body {
    overflow:hidden;
    background-color:#000000;
    color: #fff;
    /* iOS fullscreen support */
    height: 100vh;
    height: -webkit-fill-available; /* iOS Safari */
    width: 100vw;
    position: fixed;
    margin: 0;
    padding: 0;
}

/* iOS safe area support for notched devices */
@supports(padding: max(0px)) {
    body {
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
    }
}



.caption{
    position: absolute;      
    vertical-align: middle;
    margin: 10px;
    padding: 10px;
    width: 256px;
    height: 256px;      
}

.ctxt{
    padding-top:40px;
    font-size: 4px;
    text-shadow: 2px 2px #333333;
    vertical-align:middle;
    display: inline-block;
    width: 80%;
    height: 128px;
    border:0px solid #333;
}

.ajax-result {
    width: inherit;
    height: inherit;
    animation: primary 3s linear infinite;
}

#animate {
    width: 50px;
    height: 50px;
    position: absolute;
    background: red;
}

#debug {
position:absolute;
    bottom:50px;
    margin:20px;
    padding:20px;
    font-size:12px;
}

#log {
    position:absolute;
    bottom:100px;
    margin:20px;
    padding:20px;
    font-size:10px;
    height:80%;
}

.sqr {
    width:128px;
    height:128px;
    border:1px solid #222222;
}

.errors {
    position:absolute;
    text-align:left;
    vertical-align:bottom;
    bottom:0px;
    width:100%;
    height:32px;
    border:0px solid #330000;
}

a {
    background-color: white;
    border: 1px solid white;
}

a:visited {
    color: aaa;
}











body, html, button {
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    font-size: 12px;
}
.link {
    stroke: #666;
    stroke-width: 2px;
}

#svg {
    touch-action: none; /* Disable all touch gestures (pan, zoom, pinch) on SVG background */
    -ms-touch-action: none;
}

.node {
    stroke: #aaa;
    /*stroke-width: 5px;*/
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    cursor: move;
    touch-action: none; /* Prevent default touch behaviors (scrolling, zooming) on nodes */
    -webkit-touch-callout: none; /* Disable iOS callout menu */
    -webkit-user-select: none; /* Disable text selection */
    user-select: none;
}
.textClass {
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    /*font-weight: thin;*/
    font-family: monospace;
    font-size: 9px;
    padding-left:120px;
    margin-left:120px;
    left:120px;
    color:#aaa;
}

.text {
    /* display:none; */
    visibility: visible;
}

.s1 {
    /* display:none; */
    visibility: hidden;
}

#log_url {
    position: absolute;
    top:32px;
    left:32px;
    z-index:110;
    width:100%;
    height:64px;
    /*border:1px solid #aaa;*/    
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;    
    overflow: hidden;
    font-size: .4cm;
}
 
#log_text {
    position: absolute;
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    top:64px;
    left:32px;
    z-index:100;
    width:512px;
    height:80%;
    /* font-size:14px; */
    color:#333;
    overflow:hidden;
    opacity:1.5;
    white-space: pre-wrap;
    /*display:none;*/
    pointer-events: none;
    -webkit-user-select: all; /* for Safari */
    user-select: all;
    font-size: .3cm;
    display: none;
}

code {
    font-family: monospace;
    /* font-size:14px; */
}

#log_words {
    /* border: 1px solid #ffffff; */
    position: absolute;
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    bottom:10%;
    right:284px;
    z-index:100;
    width:512px;
    height:184px;
    vertical-align: bottom;
    /* font-size:22px; */
    color:#eee;
    opacity:1.5;
    /* white-space: pre-wrap; */
    font-size: .4cm;
    overflow: hidden;
    display: table-cell;  
}

#log_phrases {
    position: absolute;
    /* border: 1px solid #ffffff; */
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    bottom:40%;
    right:184px;
    z-index:100;
    width:512px;
    height:256px;
    font-size:11px;
    vertical-align: bottom;
    color:#fff;
    opacity:1.5;
    white-space: pre-wrap;
    font-size: .4cm;
    /* overflow: hidden; */
    color:#888;
    /* border:1px solid #aaa;   */
    display: table-cell;  
}

#log_events {
    position: absolute;
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    top:30%;
    left:30%;
    z-index:100;
    width:512px;
    height:364px;
    font-size:11px;
    color:#777;
    opacity:1.5;
    white-space: pre-wrap;
    font-size: .3cm;
}

#log_sub {
    position: absolute;
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    bottom:10%;
    left:10%;
    z-index:100;
    width:512px;
    height:256px;
    font-size:11px;
    color:#666;
    opacity:1.5;
    white-space: pre-wrap;
    font-size: 11px;
    overflow: hidden;
}

#log_headers {
    position: absolute;
    font-family: "Lucida Grande", "Droid Sans", Arial, Helvetica, sans-serif;
    top:64px;
    right:384px;
    z-index:100;
    width:256px;
    height:256px;
    font-size:2px;
    color:#666;
    opacity:.5;
    white-space: pre-wrap;
    overflow: hidden;
}    

#nodes{
    position:absolute;
    z-index:200;
    border:1px solid #aaa;
    /* width: 512px; */
    /* height: 512px; */
    width: 100%;
    height: 100%;
    display: none;
    /* background-color: #000000; */
}

#log {
    display:none;
}

.update_item {
    border:1px solid #ffffff;
    float:left;
}


button {
    z-index:100;
}

::-moz-selection { 
    color: white;
    background: red;
}

::selection {
    color: white;
    background: red;
}

#debug {
    z-index: 200;
    right:32px;
    bottom:32px;
    -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
        -khtml-user-select: none; /* Konqueror HTML */
        -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently */
    visibility: visible;
    opacity: 0.2;
}

#login-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    z-index: 9999;
    display: none;
    justify-content: center;
    align-items: center;
}

#login-form {
    background-color: #1a1a1a;
    padding: 40px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    width: 300px;
}

#login-form h2 {
    margin-top: 0;
    margin-bottom: 20px;
    color: #fff;
    text-align: center;
    font-size: 24px;
}

#login-form input {
    width: 100%;
    padding: 12px;
    margin-bottom: 15px;
    border: 1px solid #333;
    border-radius: 4px;
    background-color: #2a2a2a;
    color: #fff;
    font-size: 14px;
    box-sizing: border-box;
}

#login-form button {
    width: 100%;
    padding: 12px;
    background-color: #0066cc;
    color: #fff;
    border: none;
    border-radius: 4px;
    font-size: 16px;
    cursor: pointer;
}

#login-form button:hover {
    background-color: #0052a3;
}

#login-error {
    color: #ff4444;
    margin-bottom: 15px;
    text-align: center;
    font-size: 14px;
    display: none;
}

/* Responsive design for iPhone 14 and mobile devices */
/* iPhone 14: 390x844 logical pixels (1170x2532 physical) */
@media screen and (max-width: 428px) {
    body, table {
        font-size: 16px;
    }
    
    body, html, button {
        font-size: 10px;
    }
    
    #debug {
        font-size: 9px;
        padding: 10px;
        margin: 10px;
        bottom: 10px;
        right: 10px;
        max-width: calc(100% - 20px);
        overflow-x: auto;
    }
    
    #log_url {
        top: calc(10px + 20vh);
        left: 10px;
        font-size: 0.25cm;
        height: 40px;
        width: calc(100% - 20px);
        opacity: 0.3;
    }
    
    #log_text {
        top: 50px;
        left: 10px;
        width: calc(100% - 20px);
        font-size: 0.2cm;
        height: 30%;
    }
    
    #log_words {
        bottom: 5%;
        right: 10px;
        width: calc(100% - 20px);
        height: 120px;
        font-size: 0.25cm;
    }
    
    #log_phrases {
        bottom: 25%;
        right: 10px;
        width: calc((100% - 20px) / 2);
        height: 150px;
        font-size: 0.25cm;
    }
    
    #log_events {
        top: 20%;
        left: 10px;
        width: calc(100% - 20px);
        height: 200px;
        font-size: 0.2cm;
    }
    
    #log_sub {
        bottom: 15%;
        left: 10px;
        width: calc(100% - 20px);
        height: 150px;
        font-size: 9px;
    }
    
    #log_headers {
        top: 150px;
        right: 10px;
        width: calc((100% - 20px) / 2);
        max-width: 200px;
        height: 180px;
        font-size: 4px;
        /* border: 1px solid #ffffff; */
        padding: 8px;
        box-sizing: border-box;
        overflow-y: auto;
        overflow-x: hidden;
        /* background-color: rgba(0, 0, 0, 0.8); */
        color: #fff !important;
        opacity: .3 !important;
    }
    
    /* iPhone 14 Pro Max specific (430x932) */
    @media screen and (min-width: 428px) and (max-width: 432px) and (min-height: 930px) {
        #log_headers {
            top: 60px;
            right: 15px;
            width: calc((100% - 30px) / 2);
            max-width: 210px;
            height: 200px;
            font-size: 4.5px;
            padding: 10px;
            line-height: 1.4;
        }
    }
    
    /* Ensure log_headers is visible on all mobile devices */
    @media screen and (max-width: 428px) {
        #log_headers {
            visibility: visible !important;
            display: block !important;
        }
    }
    
    .textClass {
        font-size: 7px;
        padding-left: 60px;
        margin-left: 60px;
        left: 60px;
    }
    
    .node circle {
        r: 8px;
    }
    
    #login-form {
        width: calc(100% - 40px);
        max-width: 300px;
        padding: 30px 20px;
    }
    
    #login-form h2 {
        font-size: 20px;
    }
    
    #login-form input,
    #login-form button {
        font-size: 14px;
        padding: 10px;
    }
}

/* Optimize for iPhone 14 specifically (390x844) */
@media screen and (max-width: 428px) and (min-height: 800px) {
    #log_text {
        height: 35%;
    }
    
    #log_words {
        bottom: 8%;
    }
    
    #log_phrases {
        bottom: 28%;
    }
}

/* Landscape orientation for mobile */
@media screen and (max-width: 844px) and (orientation: landscape) {
    #log_text {
        height: 25%;
    }
    
    #log_words,
    #log_phrases {
        width: 48%;
    }
    
    #log_words {
        right: 1%;
    }
    
    #log_phrases {
        right: 51%;
    }
}

</style>

<body>
  
<div id="login-overlay">
  <div id="login-form">
    <h2>Login</h2>
    <div id="login-error"></div>
    <input type="text" id="username" placeholder="Username" autocomplete="username">
    <input type="password" id="password" placeholder="Password" autocomplete="current-password">
    <button onclick="handleLogin()">Login</button>
  </div>
</div>

<div id="nodes"></div>

  <div id="debug">
    
    <code>
        | value:<span id="value"></span>
        | counter:<span id="counter"></span>
        | latency:<span id="latency"></span> 
        <!-- | <a href="http://docs.arthew0.online:32768/" target="_blank">v2.1.0</a> | -->

        <span class="admin-only">
        <button onclick="do_step()">step</button>
        <button onclick="stop()">stop</button>    
        <button onclick="start()">start</button>
        <button onclick="restart()">restart</button>
        <button onclick="do_add()" style="display:none">add</button>|
        <a href="/tags/">tag cloud</a>|
        <a href="/tags/phrases/">phrases</a>|
        <a href="/api/tags/get/">get tags<span id="tags"></span></a>|
        <a href="/api/tags/add/">add tags<span id="tags"></span></a>|
        <a href="/api/tags/add_tags_from_steps/">add_tags_from_steps<span id="tags"></span></a>|
        <a href="/api/tags/clean/">clean tags<span id="clean_tags"></span></a>|
        <a href="/api/steps/">api<span id="api"></span></a>|
        <a href="/ctrl/">dashboard:<span id="dashboard"></span></a>|
        <a href="/queue/">queue:<span id="queue"></span></a>
        </span>
        <span class="admin-only">|
        <button onclick="handleLogout()">logout</button>
        </span>
        <span class="guest-only">
        <a href="#" onclick="showLoginForm(); return false;">login:<span id="login"></span></a>
        </span>

    </code>

  </div>

  <div id="log"></div>

    <span id='s1'></span>  

    <span id="log_url" class="text"></span>
    <div id="log_text" class="text"></div>
    <div id="log_phrases" class="text"></div>    
    <div id="log_sub" class="text"></div> 
    <div id="log_events" class="text"></div> 
    <div id="log_headers" class="text"></div>  
    <div id="log_urls" class="text"></div>  
    <div id="log_words" class="text"></div> 

  <span id='s2'></span>

  <div class="errors"></div>


    <!-- Load external libraries before inline scripts that depend on them -->
    <!-- This prevents "layout was forced" warnings by ensuring styles load first -->
    <script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script>
    // Load d3.js with fallback to CDN
    (function() {
        function loadD3Script(src, isFallback) {
            return new Promise(function(resolve, reject) {
                var script = document.createElement('script');
                script.src = src;
                script.onload = function() {
                    if (typeof d3 !== 'undefined') {
                        console.log('d3.js loaded successfully' + (isFallback ? ' from CDN fallback' : ''));
                        resolve();
                    } else {
                        reject(new Error('d3 object not defined after script load'));
                    }
                };
                script.onerror = function() {
                    reject(new Error('Failed to load script: ' + src));
                };
                document.head.appendChild(script);
            });
        }
        
        // Try to load from local first, then fallback to CDN
        loadD3Script('/flask_static/d3.v3.min.js', false)
            .catch(function(error) {
                console.warn('Failed to load d3 from /flask_static/, using CDN fallback:', error.message);
                return loadD3Script('https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js', true);
            })
            .catch(function(error) {
                console.error('Failed to load d3.js from both sources:', error.message);
            });
    })();
    </script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NSBDJ2XRN8"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-NSBDJ2XRN8');

// Login handling
var admin = false;

function showLoginForm() {
    document.getElementById('login-overlay').style.display = 'flex';
    // Clear previous inputs
    document.getElementById('username').value = '';
    document.getElementById('password').value = '';
    document.getElementById('login-error').style.display = 'none';
}

function handleLogin() {
    const username = document.getElementById('username').value;
    const password = document.getElementById('password').value;
    const errorDiv = document.getElementById('login-error');
    
    // Validate credentials
    if (username === 'x' && password === 'x') {
        // Hide login overlay
        document.getElementById('login-overlay').style.display = 'none';
        errorDiv.style.display = 'none';
        // Set admin flag
        admin = true;
        sessionStorage.setItem('authenticated', 'true');
        sessionStorage.setItem('admin', 'true');
        // Show admin controls
        updateAdminUI();
    } else {
        // Show error message
        errorDiv.textContent = 'Invalid username or password';
        errorDiv.style.display = 'block';
    }
}

function handleLogout() {
    // Clear admin flag
    admin = false;
    sessionStorage.removeItem('authenticated');
    sessionStorage.removeItem('admin');
    // Update UI to show guest controls
    updateAdminUI();
}

function updateAdminUI() {
    // Show/hide elements based on admin status
    const adminElements = document.querySelectorAll('.admin-only');
    const guestElements = document.querySelectorAll('.guest-only');
    
    adminElements.forEach(el => el.style.display = admin ? 'inline' : 'none');
    guestElements.forEach(el => el.style.display = admin ? 'none' : 'inline');
}

// Allow login with Enter key
document.addEventListener('DOMContentLoaded', function() {
    const passwordInput = document.getElementById('password');
    const usernameInput = document.getElementById('username');
    
    if (passwordInput) {
        passwordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
    }
    
    if (usernameInput) {
        usernameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
    }
    
    // Check if already authenticated
    if (sessionStorage.getItem('authenticated') === 'true') {
        admin = sessionStorage.getItem('admin') === 'true';
        updateAdminUI();
    } else {
        // Initialize as guest
        updateAdminUI();
    }
});







var text = "."
var url = "/"


var server = window.location.protocol + "//" + window.location.host;
console.log("server", server)

// Detect if behind /app ingress prefix and set socket.io path accordingly
var basePath = window.location.pathname.replace(/\/+$/, '');
var socketPath = basePath ? basePath + '/socket.io' : '/socket.io';
console.log("socketPath", socketPath)
var socket = io({path: socketPath});

height = 600

var counter = 0
var tag = 0
var imgs = 0

var start_time = (new Date).getTime()   
socket.on('connect', function() {  
    console.log("on connect")
    window.setInterval(function () {
        counter += 1
        start_time = (new Date).getTime();
        //console.log("semd my_ping")
        socket.emit('my_ping');
    }, 250);
});


function getLinkLength(url1, url2) {
length = "30"
if (getDomain(url1,2)==getDomain(url2,2)) {
    length = "10"
}
return length
}


    //
    // EVENT
    //
    //
    //
    //
    let log_page = ""
    let last_event_time = -1;
    let last_event = "";
    var event_time = (new Date).getTime()
    socket.on('event', function(data) {                
        if (data['event'] == "retrieve_next_url") {
            log_page = ""
            event_time = (new Date).getTime()
        }                
        const deltaTime = (new Date).getTime() - event_time;
        log_line = data['event'] + " - " + deltaTime
        log_page = log_page + "\n" + log_line
        $('#log_events').html("<code>" + log_page + "</code>");
        $('#log_text').html(counter);
        event_time = (new Date).getTime()
    })



    //
    // SUBLINKS
    //
    //
    //
    //
    let log_sub_page = ""
    let last_sub_event_time = -1;
    let last_sub_event = "";
    var event_sub_time = (new Date).getTime()
    socket.on('sublink', function(data) {        
        log_sub_line = data['url']
        log_sub_page = log_sub_line  + "\n" + log_sub_page 
        log_sub_page.substring(0, 1024);
        $('#log_sub').html("<code>" + log_sub_page + "</code>");
        //$('#log_text').html(counter);
        event_sub_time = (new Date).getTime()
    })



    socket.on('clear', function(data){
        console.log("clear")
        url = ""
        text = ""    
        graph.removeAllNodes()
        graph.removeallLinks()
    })



    //
    // STEP
    //
    //
    //
    //
    //
    //
    let timeoutId = -1;
    let last_added = "";
    socket.on('step', function(data) {
        clearTimeout(timeoutId);
        console.log(data)
        step = data['step']
        url = data['url'];
        from_url = data['src_url'];    
        struct_text = data['struct_text']
        text = data['text']
        words = data['words']

        if (data.analyzed) {
            words_count = data.analyzed.words_count;
            words_count = Math.min(words_count/10+5, 20);
        } else {
            words_count = Math.random() * 700.0;
            words_count = Math.min(words_count/10+5, 20);
        }

        // Send midi notes
        
        // if (navigator.requestMIDIAccess) {
        //     navigator.requestMIDIAccess().then(midiAccess => {
        //         const outputs = Array.from(midiAccess.outputs.values());
        //         if (outputs.length === 0) {
        //             console.error("No midi devices");
        //             return;
        //         }
        //         const output = outputs[1]; 
        //         const noteOn = [0x90, words_count*3, 127]; // Note On (канал 1, нота C4, velocity 127)
        //         output.send(noteOn);
        //         setTimeout(() => {
        //             output.send([0x80, words_count*3, 0]); // Note Off (канал 1, нота C4, velocity 0)
        //         }, 100);
        //     }).catch(error => {
        //         console.error("MIDI access error: ", error);
        //     });
        // } else {
        //     console.error("navigator.requestMIDIAccess is not supported in this browser.");
        // }


        // add node and delete fifo
        graph.add_node_safe(step, url, from_url, words_count)


        var log_view = document.getElementById('log_url');
        log_view.innerHTML = "<a href='" + url + "'><code><nobr>" + step + " : " + url + "</nobr></code></a>";

        function updateData(selectedNode)  {
            diff.removed.forEach((node) => nodes.splice(nodes.indexOf(node), 1))
        }








        let textLength = 2048;
        if (textLength < 2048) {
            textLength = text.length
        }
        let delay = 4
        let index = 0;
        function animateText() {            
            const element = document.getElementById( "log_text")
            if (text)
                if (index < text.length) {              
                    element.innerHTML = "<code>"+text.slice(0, index)+"</code>";
                    var rng = document.createRange();
                    rng.setStartBefore( document.getElementById('s1') );
                    rng.setEndAfter( document.getElementById('s2') );
                    //document.getSelection().addRange(rng);    
                    index+=10;
                    timeoutId = setTimeout(animateText, delay);
                } else {
                    clearTimeout(timeoutId);
                }
        }    
        animateText();
            
        //typeString(text, "log_text", 2); //log_img(text)    
        if (data.analyzed) {
            document.getElementById("log_words").innerHTML = "<code>" + data.analyzed.words.join(', ') + "</code>";
        }
        if (struct_text) {
            // Animate log_phrases like log_text
            let phrasesTextLength = struct_text.length;
            // Calculate delay to show all text in 2 seconds (2000ms)
            // Since we increment by 10 characters per step, delay = (2000ms / total_chars) * 10
            let phrasesDelay = phrasesTextLength > 0 ? Math.max(1, (2000 / phrasesTextLength) * 10) : 8;
            let phrasesIndex = 0;
            let phrasesTimeoutId = -1;
            
            function animatePhrases() {
                const phrasesElement = document.getElementById("log_phrases");
                if (struct_text) {
                    if (phrasesIndex < struct_text.length) {
                        phrasesElement.innerHTML = "<code>" + struct_text.slice(0, phrasesIndex) + "</code>";
                        phrasesIndex += 10;
                        phrasesTimeoutId = setTimeout(animatePhrases, phrasesDelay);
                    } else {
                        clearTimeout(phrasesTimeoutId);
                    }
                }
            }
            animatePhrases();
        }

        // Animate log_headers letter by letter
        let headersText = data['headers'] || '';
        let headersIndex = 0;
        let headersTimeoutId = -1;
        // Calculate delay to show all text in 0.7 seconds (700ms)
        // Since we increment by 10 characters per step, delay = (700ms / total_chars) * 10
        let headersDelay = headersText.length > 0 ? Math.max(1, (700 / headersText.length) * 10) : 8;
        
        function animateHeaders() {
            const headersElement = document.getElementById("log_headers");
            if (headersText) {
                if (headersIndex < headersText.length) {
                    headersElement.innerHTML = "<code>" + headersText.slice(0, headersIndex) + "</code>";
                    headersIndex += 10;
                    headersTimeoutId = setTimeout(animateHeaders, headersDelay);
                } else {
                    clearTimeout(headersTimeoutId);
                }
            }
        }
        animateHeaders();
        //typeString(url, "log_url", 1); //log_msg(info)


        // console.log("semantic_words", data['semantic_words'])
        set_semantic_woords_from_array(step, data['semantic_words'])


    }); // socket on step




    //
    //
    //
    function set_semantic_woords_from_array(step_number, semantic_words_array) {
        let words = semantic_words_array
        let sindex = 0;
        let stimeoutId = 0
        words_all = "END" 

        function sanimateText() {            
            if (sindex < words.length) {     
                swords = words.slice(sindex, sindex+1)[0];            
                if (swords != "") {
                    words_all = swords + ", " + words_all;
                }
                sindex += 1;
                document.getElementById("log_words").innerHTML = "<code><h3>Step " + step_number + " semantic</h3>" + words_all + "</code>";
                stimeoutId = setTimeout(sanimateText, 600);
            } else {
                clearTimeout(stimeoutId);
            }
        }    
        sanimateText();

        //document.getElementById("log_phrases").innerHTML = "<code><h3>noun_phrases</h3>" + data['noun_phrases'].join('<br>') + "</code>";
        //words_all = data['words_str'] + words_all
        //words = data['words']
        //node = graph.findNode(data.url);
        //node.data = data;
        //node.r = data.sentences;
        //console.log(node, node.data); 
        //document.getElementById("log_words").innerHTML = "<code>" + words_all + "</code>";        
    }



    socket.on('set_values', function(data) {
        // console.log('set_values', data);
        graph.setValues(data)        
        $('#value').html(data['v1']);
    });


    //
    // ANALYZED
    //
    //
    //
    //
    //
    //
    words_all = ""
    socket.on('analyzed', function(data) {
        
        let words = data['words_str'].split(" ")
        let sindex = 0;
        let stimeoutId = 0
        function sanimateText() 
        {            
            if (sindex < words.length) {     
                swords = words.slice(sindex, sindex+1)[0];            
                if (swords != "") {
                    words_all = swords + ", " + words_all;
                }
                sindex += 1;
                document.getElementById("log_words").innerHTML = "<code><h3>semantic</h3>" + words_all + "</code>";
                stimeoutId = setTimeout(sanimateText, 600);
            } else {
                clearTimeout(stimeoutId);
            }
        }    
        sanimateText();

        // Animate log_phrases for analyzed data
        let analyzedPhrases = "<h3>noun_phrases</h3>" + data['noun_phrases'].join('<br>');
        let analyzedPhrasesIndex = 0;
        let analyzedPhrasesTimeoutId = -1;
        // Calculate delay to show all text in 2 seconds (2000ms)
        // Since we increment by 10 characters per step, delay = (2000ms / total_chars) * 10
        let analyzedPhrasesDelay = analyzedPhrases.length > 0 ? Math.max(1, (2000 / analyzedPhrases.length) * 10) : 8;
        
        function animateAnalyzedPhrases() {
            const phrasesElement = document.getElementById("log_phrases");
            if (analyzedPhrasesIndex < analyzedPhrases.length) {
                phrasesElement.innerHTML = "<code>" + analyzedPhrases.slice(0, analyzedPhrasesIndex) + "</code>";
                analyzedPhrasesIndex += 10;
                analyzedPhrasesTimeoutId = setTimeout(animateAnalyzedPhrases, analyzedPhrasesDelay);
            } else {
                clearTimeout(analyzedPhrasesTimeoutId);
            }
        }
        animateAnalyzedPhrases();

        //words_all = data['words_str'] + words_all
        //words = data['words']
        //node = graph.findNode(data.url);
        //node.data = data;
        //node.r = data.sentences;
        //console.log(node, node.data); 
        //document.getElementById("log_words").innerHTML = "<code>" + words_all + "</code>";
    })




    socket.on('my_pong', function () {
        const latency = (new Date).getTime() - start_time;
        $('#latency').html(latency);
        $('#counter').html(counter);
    });

    socket.on('disconnect', function() {
        console.log('Disconnected from server');
    });




  function reset() {
    console.log("reset")
    //d3.select("svg").remove();
    //drawGraph();
    socket.emit('reset');
  }

  function stop() {
    console.log("stop")
    url = ""
    text = ""    
    graph.removeAllNodes()
    graph.removeallLinks()
    socket.emit('stop');
  }

  function start() {
    console.log("start")
    socket.emit('start');
  }

  function restart() {
    console.log("restart")
    // url = ""
    // text = ""    
    // graph.removeAllNodes()
    // graph.removeallLinks()
    socket.emit('restart');
  }

  function do_step() {
    console.log("step")
    socket.emit('step');
  }

  function do_add() {
    new_id = "URL" + Math.random() * 1000
    console.log("add", new_id)
    // socket.emit('add');

    graph.addNode(new_id);
    graph.addLink(new_id, "URL1", '10');
  }


function getDomain(url, subdomain) {
    subdomain = subdomain || false;
    url = url.replace(/(https?:\/\/)?(www.)?/i, '');
    if (!subdomain) {
        url = url.split('.');
        url = url.slice(url.length - 2).join('.');
    }
    if (url.indexOf('/') !== -1) {
        return url.split('/')[0];
    }
    return url;
}


var values = {'v1':0.25, "v2": 0.25, "v3":0.25, "v4":0.25, "v5":0.25, "v6":0.25, "v7":0.25}

// Detect retina display and return link distance multiplier
function getLinkDistanceMultiplier() {
    // Retina displays have devicePixelRatio >= 2
    if (window.devicePixelRatio >= 2) {
        return 0.5; // Reduce link length by half (x2 smaller)
    }
    return 1.0; // Normal display
}

var zoom;
var container;

function zoomed() {
    container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

var graph;

function myGraph() {

    var nodes = []
    var links = []
    
    this.getNodes = function() {
        return nodes
    }
    // Add and remove elements on the graph object
    this.addNode = function (id, step, r=6) {
        //console.log(r)
        nodes.push({"id": id, "step": step, "r": r});
        update();
        return id
    };

    this.removeNode = function(id) {
        var i = 0;
        var n = findNode(id);            
        while (i < links.length) {
            if ((links[i].source.id == id) || (links[i].source.id == id)) {
                links.splice(i, 1);
            }
            else i++;
        }
        nodes.splice(this.findNodeIndex(id), 1);
        update();
    };

    this.removeLink = function (source, target) {
        for (var i = 0; i < links.length; i++) {
            if (links[i].source.id == source && links[i].target.id == target) {
                links.splice(i, 1);
                break;
            }
        }
        update();
    };

    this.removeallLinks = function () {
        links.splice(0, links.length);
        update();
    };

    this.removeAllNodes = function () {
        nodes.splice(0, links.length);
        update();
    };

    this.addLink = function (source, target, value) {
        links.push({"source": findNode(source), "target": findNode(target), "value": value});
        update();
    };

    this.findNode = function (id) {
        for (var i in nodes) {
            if (nodes[i]["id"] === id) return nodes[i];
        };
    };

    this.removeLinksForNode = function (node_id) {
        i = 0;
        while (i < links.length) {
            if (links[i].source.id == node_id || links[i].target.id == node_id) {
                links.splice(i, 1);
            } else {
                i+=1;
            }
        }
        update();
    }; 

    var findNode = function (id) {

        for (var i in nodes) {
            if (nodes[i]["id"] === id) return nodes[i];
        };
    };

    this.findNodeIndex = function (id) {
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].id == id) {
                return i;
            }
        };
    };

    // set up the D3 visualisation in the specified element
    var w = window.innerWidth,
    h = window.innerHeight;
    var aspect = w / h;

    // const container = d3.select(graph.node().parentNode)
    function isMobile() {
        const regex = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
        return regex.test(navigator.userAgent);
    }
    
    function isIPhone() {
        return /iPhone/.test(navigator.userAgent);
    }

    var color = d3.scale.category10();
    var scale = 1;
    
    if (isMobile()) {
        // Optimize scale for mobile devices
        // iPhone 14: 390x844 logical pixels
        if (isIPhone() && w <= 428) {
            scale = 1.0; // Use 1:1 scale for iPhone to prevent oversizing
        } else {
            scale = 1.2; // Slightly larger for other mobile devices
        }
    }
    var vis = d3.select("body")
        .append("svg:svg")
        .attr("width", Math.floor(w*scale))
        .attr("height", Math.floor(h*scale))
        .attr("id", "svg")
        .attr("pointer-events", "all")
        .attr("viewBox", "0 0 " + Math.floor(w*scale) + " " + Math.floor(h*scale))
        .attr("perserveAspectRatio", "xMinYMid");

    // Create container group for zoom/pan
    container = vis.append("g");

    // Configure zoom behavior - disable drag/pan, only allow zoom via buttons
    zoom = d3.behavior.zoom()
        .scaleExtent([0.1, 10]) // Limit zoom between 0.1x and 10x
        .on("zoom", zoomed);

    // Apply zoom to SVG but disable drag/pan gestures
    // Only allow zoom via buttons, not by dragging or pinching
    vis.call(zoom)
        .on("mousedown.zoom", null)  // Disable mouse drag pan
        .on("touchstart.zoom", null) // Disable touch pan
        .on("touchmove.zoom", null)  // Disable touch pan
        .on("touchend.zoom", null);  // Disable touch pan


    d3.select("body").append("button")
    .text("-")
    .on("click", function() {
        zoom.scale(zoom.scale() / 1.2);
        zoom.event(vis.transition().duration(500));
    });

    function handleMouseOver(d, i) {
        console.log("over", d, i)
    }

    function handleMouseOut(d, i) {
        console.log("out", d, i)
    }
    
    function resize() {
        var w = window.innerWidth;
        var h = window.innerHeight;
        
        // Adjust scale for mobile on resize
        if (isMobile()) {
            if (isIPhone() && w <= 428) {
                scale = 1.0;
            } else {
                scale = 1.2;
            }
        } else {
            scale = 1.0;
        }
        
        //const targetWidth = window.innerWidth;
        //graph.attr('width', w);
        //graph.attr('height', Math.round(w / aspect));        
        vis.attr("width", Math.floor(w*scale)).attr("height", Math.floor(h*scale))
            .attr("viewBox", "0 0 " + Math.floor(w*scale) + " " + Math.floor(h*scale));
    }

    window.addEventListener('resize', function (event) {
        //console.log('Произошло событие', event.type)
        resize();
    })

    resize()
    console.log(w, h)

    var force = d3.layout.force();

    var nodes = force.nodes(),
    links = force.links();


    var update = function () {

        //console.log("update")
        
        links = force.links();

        var link = container.selectAll("line")
            .data(links, function (d) {                    
                return d.source.id + "-" + d.target.id;
            });

        link.enter().append("line")
            .attr("id", function (d) {
                if (d.source && d.target)
                return d.source.id + "-" + d.target.id;
            })
            .attr("stroke-width", function (d) {
                return d.value / 1;
            })
            .attr("class", "link");

        link.append("title")
               .text(function (d) {
                   return d.value;
               });

        link.exit().remove();

        var node = container.selectAll("g.node")
            .data(nodes, function (d) {
                //console.log("selectAll", d)
                return d.id;
            });

        // Custom drag handler that works with both mouse and touch
        var customDrag = force.drag()
            .on("dragstart", function(d) {
                // Prevent graph panning when dragging nodes
                d3.event.sourceEvent.stopPropagation();
                // Prevent default touch behavior (scrolling, zooming)
                if (d3.event.sourceEvent.type === "touchstart") {
                    d3.event.sourceEvent.preventDefault();
                }
            })
            .on("drag", function(d) {
                // Prevent graph panning during drag
                d3.event.sourceEvent.stopPropagation();
                if (d3.event.sourceEvent.type === "touchmove") {
                    d3.event.sourceEvent.preventDefault();
                }
            })
            .on("dragend", function(d) {
                // Prevent graph panning when drag ends
                d3.event.sourceEvent.stopPropagation();
                if (d3.event.sourceEvent.type === "touchend") {
                    d3.event.sourceEvent.preventDefault();
                }
            });

        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .call(customDrag);

        // Adjust node size for mobile
        var nodeSizeMultiplier = isMobile() && w <= 428 ? 0.8 : 1.2;
        
        nodeEnter.append("svg:circle")
            .attr("r", function (d) {return d.r*nodeSizeMultiplier;})
            .attr("id", function (d) {return "Node;" + d.id;})
            .attr("class", "nodeStrokeClass")
            //.attr("fill", function(d) { return color(d.id); });

        // Adjust text positioning for mobile
        var textX = isMobile() && w <= 428 ? 20 : 28;
        
        nodeEnter.append("svg:text")
            .attr("class", "textClass")
            .attr("x", textX)
            .attr("y", ".31em")
            .text(function (d) {return d.step  + ": " + d.id;
            });

        // Apply drag handler to all nodes (both new and existing)
        node.call(customDrag);

        node.exit().remove();

        force.on("tick", function () {
            node.attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
            link.attr("x1", function (d) {
                return d.source.x;
            })
            .attr("y1", function (d) {
                return d.source.y;
            })
            .attr("x2", function (d) {
                return d.target.x;
            })
            .attr("y2", function (d) {
                return d.target.y;
            });
        });


        // console.log(force, values); 
        // Restart the force layout.
        var linkMultiplier = getLinkDistanceMultiplier();
        force.linkDistance( function(d) { return d.value * 13 * values['v1'] * 4 * linkMultiplier } )
            .gravity(.01 * values['v2'] * 4 )
            .charge(-80000*values['v3'] * 4 )              
            .linkStrength(values['v4'])
            .friction(0.004*values['v5'] * 4 )  
            .size([w, h])
            .start();     
    };


    this.setValues = function (v) {      
        values = v
        var linkMultiplier = getLinkDistanceMultiplier();
        force.linkDistance( function(d) { return d.value * 13 * values['v1'] * 4 * linkMultiplier } )
            .gravity(.01 * values['v2'] * 4 )
            .charge(-80000*values['v3'] * 4 )              
            .linkStrength(values['v4'])
            .friction(0.004*values['v5'] * 4 )  
            .size([w, h])
            .start();
             
    }


    this.add_node_safe = function(step, url, from_url, words_count) 
    {
        node_id = this.addNode(url, step, words_count);

        node_src = findNode(from_url)
        if (!node_src) {
            this.addNode(from_url, 0);
            this.addLink(from_url, url,  getLinkLength(url, from_url));
        }

        if (this.findNodeIndex(from_url)) {
            this.addLink(from_url, url, '15');
        }

        if (last_added) {
            this.addLink(last_added, url, getLinkLength(url, last_added));
        }

        last_added = url
        keepNodesOnTop();

        // Limit Nodes
        let MAX_NODES = 100
        while (this.getNodes().length > MAX_NODES) {
            this.removeNode(this.getNodes()[0].id)
        }
    }


    // Make it all go
    update();
    this.upd = function() {
        update()
    }
};

// Ensure d3 is loaded before initializing graph
var graphInitAttempts = 0;
var maxGraphInitAttempts = 50; // 5 seconds max wait time

function initGraph() {
    if (typeof d3 === 'undefined') {
        graphInitAttempts++;
        if (graphInitAttempts >= maxGraphInitAttempts) {
            console.error('d3.js failed to load after multiple attempts. Please check your network connection or server configuration.');
            return;
        }
        setTimeout(initGraph, 100);
        return;
    }
    console.log('d3.js loaded successfully, initializing graph...');
    graph = new myGraph("#svgdiv");
}

// Wait a bit for scripts to load, then initialize
setTimeout(initGraph, 50);

//function drawGraph() {}
//drawGraph();
// var linkDistanceVal = 1000 * 0.5;
// var linkStrengtVal = 10 * 0.5;
// var alphaVal = 1 * 0.5;

 




// because of the way the network is created, nodes are created first, and links second,
// so the lines were on top of the nodes, this just reorders the DOM to put the svg:g on top
function keepNodesOnTop() {
    $(".nodeStrokeClass").each(function( index ) {
        var gnode = this.parentNode;
        gnode.parentNode.appendChild(gnode);
    });
};











if (false) {
    graph.addNode("URL0", 0, 0);
    graph.addNode("URL1", 0, 10);
    graph.addNode("URL2", 0, 20);
    graph.addNode("URL3", 0, 30);
    graph.addLink("URL0", "URL1", '10');
    graph.addLink("URL0", "URL2", '10');
    graph.addLink("URL1", "URL2", '10');
    graph.addLink("URL1", "URL3", '10');
    graph.removeNode("URL0")
    graph.removeLinksForNode("URL0")

    node = graph.findNode("URL1");
    node.r = 20;
    node.value = 5

    node = graph.findNode("URL2");
    node.r = 30;
    console.log(node);
    graph.upd();

} else {
    // graph.addNode("http://arthew0.online", 0);
}

let showGraph = true;

function showGraphView() {
    var graphEl = document.getElementById('graph-container');
    var cloudEl = document.getElementById('semantic-cloud-container');
    if (graphEl) graphEl.style.display = 'block';
    if (cloudEl) cloudEl.style.display = 'none';
}

function showSemanticCloudView() {
    var graphEl = document.getElementById('graph-container');
    var cloudEl = document.getElementById('semantic-cloud-container');
    if (graphEl) graphEl.style.display = 'none';
    if (cloudEl) cloudEl.style.display = 'block';
}

// Автоматическое переключение каждую минуту
setInterval(() => {
    showGraph = !showGraph;
    if (showGraph) {
        showGraphView();
    } else {
        showSemanticCloudView();
    }
}, 60000); // 60000 мс = 1 минута

// При загрузке страницы показываем граф
showGraphView();













    </script>

</body>
</html>